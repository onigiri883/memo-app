<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ちょいメモ Web</title>
<style>
  :root {
    --bg: #f0f2f5;
    --panel: #ffffff;
    --accent: #007aff;
    --muted: #8e8e93;
    --danger: #ff3b30;
    --border-color: #d1d1d6;
    --text-primary: #000000;
    --text-secondary: #3c3c43;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    color: var(--text-primary);
    font: 16px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    -webkit-tap-highlight-color: transparent;
  }
  .app {
    max-width: 720px;
    height: 100%;
    margin: 0 auto;
    background: var(--panel);
    display: flex;
    flex-direction: column;
    box-shadow: none;
    border-radius: 0;
  }
  .header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
  }
  .header .title {
    font-size: 18px;
    font-weight: 600;
  }
  .tabs {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none; /* Firefox */
    /* Avoid unintended text selection / callout while dragging on mobile */
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  .tabs::-webkit-scrollbar {
    display: none; /* Chrome, Safari */
  }
  .tab {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    height: 40px;
    padding: 0 16px;
    border-radius: 10px;
    background: var(--bg);
    color: var(--text-secondary);
    user-select: none;
    white-space: nowrap;
    border: 1px solid transparent;
    transition: background-color 0.2s, color 0.2s;
  }
  .tab.active {
    background: var(--accent);
    color: #fff;
    font-weight: 500;
  }
  .tab.drag-over {
    outline: 2px dashed rgba(0,122,255,.6);
    outline-offset: 2px;
  }
  .tab .label {
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .tab .drag-handle {
    cursor: grab;
    color: var(--muted);
    margin-right: 8px;
    touch-action: none; /* Prevent scrolling when dragging the handle */
  }
  .tab input.title-edit {
    height: 24px;
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 6px;
    border: 1px solid var(--accent);
    outline: none;
    width: 120px;
    background: #fff;
  }
  /* Allow selection inside editing input even if parent disables selection */
  .tabs input.title-edit {
    -webkit-user-select: text;
    user-select: text;
  }
  .tabs.dragging { cursor: grabbing; }
  .icon-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    font-size: 14px;
    margin-left: -4px;
  }
  .icon-btn.danger {
    color: var(--danger);
  }
  .icon-btn:hover { 
    background: rgba(0,0,0,0.05);
  }
  .tabs-footer {
    padding: 8px 16px;
    border-bottom: 1px solid var(--border-color);
  }
  .editor-wrap {
    flex-grow: 1;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .editor {
    flex-grow: 1;
    width: 100%;
    box-sizing: border-box;
    resize: none;
    border: none;
    padding: 0;
    font-size: 17px;
    line-height: 1.6;
    background: transparent;
    outline: none;
  }
  .toolbar {
    display: flex;
    justify-content: flex-end;
  }
  .btn {
    padding: 10px 16px;
    border-radius: 10px;
    border: none;
    background: var(--accent);
    color: #fff;
    cursor: pointer;
    font-size: 16px;
    font-weight: 500;
  }
  .btn.primary {
    background: var(--accent);
  }
  .btn:hover { 
    opacity: 0.9;
  }

  /* Remove Desktop specific styles from media query */
  @media (max-width: 600px) {
    .app {
      margin: 0;
      border-radius: 0;
    }
  }
</style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title">ちょいメモ Web</div>
      <div style="margin-left:auto; color:#8b9096; font-size:12px">ダブルタップ/ダブルクリックでタブ名編集／ドラッグで並び替え</div>
    </div>

    <div class="tabs" id="tabs"></div>
    <div class="tabs-footer">
      <button class="btn primary" id="addBtn">＋ 新しいメモ</button>
    </div>

    <div class="editor-wrap">
      <textarea id="editor" class="editor" placeholder="ここにメモを入力..."></textarea>
      <div class="toolbar">
        <button class="btn" id="copyBtn">クリップボードにコピー</button>
      </div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const LS_KEY = 'choi-memo-web';
  let state = load() ?? {
    memos: [{ id: uuid(), title: 'メモ1', content: '', createdAt: Date.now() }],
    selectedIndex: 0
  };

  const tabsEl = document.getElementById('tabs');
  const editorEl = document.getElementById('editor');
  const addBtn   = document.getElementById('addBtn');
  const copyBtn  = document.getElementById('copyBtn');

  let dragSourceIndex = null;

  function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
      const r = crypto.getRandomValues(new Uint8Array(1))[0] & 15;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function save() { localStorage.setItem(LS_KEY, JSON.stringify(state)); }
  function load() {
    try { return JSON.parse(localStorage.getItem(LS_KEY) || 'null'); }
    catch { return null; }
  }

  function currentMemo() { return state.memos[state.selectedIndex]; }

  function setSelected(index) {
    state.selectedIndex = Math.max(0, Math.min(index, state.memos.length - 1));
    save();
    render();
  }

  function addMemo() {
    const n = state.memos.length + 1;
    state.memos.push({ id: uuid(), title: `メモ${n}`, content: '', createdAt: Date.now() });
    setSelected(state.memos.length - 1);
  }

  function deleteMemo(index) {
    if (state.memos.length <= 1) return;
    state.memos.splice(index, 1);
    if (state.selectedIndex >= state.memos.length) state.selectedIndex = state.memos.length - 1;
    save();
    render();
  }

  function updateTitle(index, newTitle) {
    const t = (newTitle || '').trim();
    if (!t) return;
    state.memos[index].title = t;
    save();
    render();
  }

  function moveMemo(source, destination) {
    if (source === destination) return;
    destination = Math.max(0, Math.min(destination, state.memos.length - 1));
    const m = state.memos.splice(source, 1)[0];
    if (source < destination) destination -= 1;
    state.memos.splice(destination, 0, m);

    if (state.selectedIndex === source) {
      state.selectedIndex = destination;
    } else if (source < state.selectedIndex && state.selectedIndex <= destination) {
      state.selectedIndex -= 1;
    } else if (destination <= state.selectedIndex && state.selectedIndex < source) {
      state.selectedIndex += 1;
    }
    save();
    render();
  }


  function renderTabs() {
    tabsEl.innerHTML = '';
    state.memos.forEach((memo, index) => {
      const tab = document.createElement('div');
      tab.className = 'tab' + (index === state.selectedIndex ? ' active' : '');
      tab.setAttribute('draggable', 'true');

      const label = document.createElement('span');
      label.className = 'label';
      label.textContent = memo.title;
      label.title = memo.title;

      const del = document.createElement('button');
      del.className = 'icon-btn danger';
      del.innerHTML = '&#x2715;';
      del.title = '削除';
      del.onclick = (e) => { e.stopPropagation(); deleteMemo(index); };
      if (state.memos.length <= 1) del.style.visibility = 'hidden';

      tab.appendChild(label);
      tab.appendChild(del);
      // --- Touch: Tap (switch) / Double-tap (rename) / Drag (reorder) ---
      let lastTapTime = 0;
      let touchStartTime = 0;
      let tapTimerId = null;
      let touchStartX = 0, touchStartY = 0;
      let touchDragActive = false;
      let touchDragStartIndex = null;
      let touchDragTargetIndex = null;

      const getTabIndexFromPoint = (x, y) => {
        const el = document.elementFromPoint(x, y);
        const t = el && el.closest ? el.closest('.tab') : null;
        if (!t) return null;
        const children = Array.from(tabsEl.children);
        const idx = children.indexOf(t);
        return idx >= 0 ? idx : null;
      };

      tab.addEventListener('touchstart', (e) => {
        if (e.target.closest('button')) return; // 削除ボタンは除外
        touchStartTime = Date.now();
        const t = e.touches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchDragActive = false;
        touchDragStartIndex = index;
        // prevent 300ms delay and iOS callout
        tabsEl.classList.add('dragging');
        e.preventDefault();
      }, { passive: true });

      tab.addEventListener('touchmove', (e) => {
        if (e.target.closest('button')) return;
        const t = e.touches[0];
        const dx = Math.abs(t.clientX - touchStartX);
        const dy = Math.abs(t.clientY - touchStartY);
        if (!touchDragActive && (dx > 12 || dy > 12)) {
          touchDragActive = true;
        }
        if (touchDragActive) {
          const idx = getTabIndexFromPoint(t.clientX, t.clientY);
          if (idx !== null) {
            Array.from(tabsEl.children).forEach((c, i) => {
              if (i === idx) c.classList.add('drag-over');
              else c.classList.remove('drag-over');
            });
            touchDragTargetIndex = idx;
          }
          e.preventDefault();
        }
      }, { passive: false });

      tab.addEventListener('touchend', (e) => {
        if (e.target.closest('button')) return;
        const now = Date.now();
        const duration = now - touchStartTime;

        if (touchDragActive) {
          Array.from(tabsEl.children).forEach((c) => c.classList.remove('drag-over'));
          if (touchDragStartIndex !== null && touchDragTargetIndex !== null && touchDragTargetIndex !== touchDragStartIndex) {
            moveMemo(touchDragStartIndex, touchDragTargetIndex);
          }
          touchDragActive = false;
          touchDragStartIndex = null;
          touchDragTargetIndex = null;
          tabsEl.classList.remove('dragging');
          e.preventDefault();
          return;
        }

        // 長押しは無視（名前変更しない）
        if (duration >= 450) { lastTapTime = 0; tabsEl.classList.remove('dragging'); return; }

        if (now - lastTapTime < 300) {
          // Double tap → rename
          if (tapTimerId) { clearTimeout(tapTimerId); tapTimerId = null; }
          startEditTitle(tab, index, memo.title);
          lastTapTime = 0;
        } else {
          // Single tap → switch (delay)
          lastTapTime = now;
          tapTimerId = setTimeout(() => {
            if (lastTapTime === now) setSelected(index);
          }, 320);
        }
        tabsEl.classList.remove('dragging');
      });

      // --- Double Click for Desktop ---
      tab.addEventListener('dblclick', (e) => {
        if (e.target === handle || e.target.closest('button')) return;
        startEditTitle(tab, index, memo.title);
      });

      // --- Drag & Drop Logic (Desktop, Tab Draggable) ---
      tab.addEventListener('dragstart', (e) => {
        dragSourceIndex = index;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', String(index));
        tab.style.opacity = '0.5';
      });
      tab.addEventListener('dragend', () => {
        tab.style.opacity = '1';
      });
      
      tab.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        tab.classList.add('drag-over');
      });
      
      tab.addEventListener('dragleave', () => {
        tab.classList.remove('drag-over');
      });
      
      tab.addEventListener('drop', (e) => {
        e.preventDefault();
        tab.classList.remove('drag-over');
        const src = dragSourceIndex ?? parseInt(e.dataTransfer.getData('text/plain') || '-1', 10);
        if (!Number.isInteger(src) || src < 0 || src === index) return;
        moveMemo(src, index);
        dragSourceIndex = null;
      });

      
      tabsEl.appendChild(tab);
    });
  }

  function startEditTitle(tab, index, currentTitle) {
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'title-edit';
    input.value = currentTitle;
    input.onblur = () => finishEditTitle(tab, index, input.value);
    input.onkeydown = (e) => {
      if (e.key === 'Enter') {
        finishEditTitle(tab, index, input.value);
      } else if (e.key === 'Escape') {
        renderTabs(); // キャンセルして元に戻す
      }
    };
    tab.replaceChild(input, tab.querySelector('.label'));
    input.focus();
  }

  function finishEditTitle(tab, index, newTitle) {
    updateTitle(index, newTitle);
    renderTabs();
  }

  function renderEditor() {
    const memo = currentMemo();
    editorEl.value = memo?.content ?? '';
  }

  function render() {
    renderTabs();
    renderEditor();
  }

  // events
  editorEl.addEventListener('input', () => {
    editorEl.style.height = 'auto';
    editorEl.style.height = editorEl.scrollHeight + 'px';
  });

  addBtn.addEventListener('click', addMemo);

  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(editorEl.value ?? '');
      copyBtn.textContent = 'コピーしました';
      setTimeout(()=> copyBtn.textContent = 'クリップボードにコピー', 1200);
    } catch {
      alert('コピーに失敗しました');
    }
  });



  // init
  render();
});
</script>
</body>
</html>